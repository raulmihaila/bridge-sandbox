{"version":3,"file":"graphql.e47d18d9.js","sources":["../../../hoppscotch-common/src/composables/graphql.ts"],"sourcesContent":["import * as E from \"fp-ts/Either\"\nimport { pipe } from \"fp-ts/function\"\nimport {\n  reactive,\n  ref,\n  Ref,\n  unref,\n  isRef,\n  watchEffect,\n  WatchStopHandle,\n  watchSyncEffect,\n  watch,\n} from \"vue\"\nimport {\n  client,\n  GQLError,\n  parseGQLErrorString,\n} from \"@helpers/backend/GQLClient\"\nimport {\n  createRequest,\n  GraphQLRequest,\n  OperationResult,\n  TypedDocumentNode,\n} from \"@urql/core\"\nimport { Source, pipe as wonkaPipe, onEnd, subscribe } from \"wonka\"\n\ntype MaybeRef<X> = X | Ref<X>\n\ntype UseQueryOptions<T = any, V = object> = {\n  query: TypedDocumentNode<T, V>\n  variables?: MaybeRef<V>\n\n  updateSubs?: MaybeRef<GraphQLRequest<any, object>[]>\n  defer?: boolean\n  pollDuration?: number | undefined\n}\n\nexport const useGQLQuery = <DocType, DocVarType, DocErrorType extends string>(\n  _args: UseQueryOptions<DocType, DocVarType>\n) => {\n  const stops: WatchStopHandle[] = []\n\n  const args = reactive(_args)\n\n  const loading: Ref<boolean> = ref(true)\n  const isStale: Ref<boolean> = ref(true)\n  const data: Ref<E.Either<GQLError<DocErrorType>, DocType>> = ref() as any\n\n  if (!args.updateSubs) args.updateSubs = []\n\n  const isPaused: Ref<boolean> = ref(args.defer ?? false)\n\n  const pollDuration: Ref<number | null> = ref(args.pollDuration ?? null)\n\n  const request: Ref<GraphQLRequest<DocType, DocVarType>> = ref(\n    createRequest<DocType, DocVarType>(\n      args.query,\n      unref<DocVarType>(args.variables as any) as any\n    )\n  ) as any\n\n  const source: Ref<Source<OperationResult> | undefined> = ref()\n\n  // Toggles between true and false to cause the polling operation to tick\n  const pollerTick: Ref<boolean> = ref(true)\n\n  stops.push(\n    watchEffect((onInvalidate) => {\n      if (pollDuration.value !== null && !isPaused.value) {\n        const handle = setInterval(() => {\n          pollerTick.value = !pollerTick.value\n        }, pollDuration.value)\n\n        onInvalidate(() => {\n          clearInterval(handle)\n        })\n      }\n    })\n  )\n\n  stops.push(\n    watchEffect(\n      () => {\n        const newRequest = createRequest<DocType, DocVarType>(\n          args.query,\n          unref<DocVarType>(args.variables as any) as any\n        )\n\n        if (request.value.key !== newRequest.key) {\n          request.value = newRequest\n        }\n      },\n      { flush: \"pre\" }\n    )\n  )\n\n  const rerunQuery = () => {\n    source.value = !isPaused.value\n      ? client.value.executeQuery<DocType, DocVarType>(request.value, {\n          requestPolicy: \"network-only\",\n        })\n      : undefined\n  }\n\n  stops.push(\n    watch(\n      pollerTick,\n      () => {\n        rerunQuery()\n      },\n      {\n        flush: \"pre\",\n      }\n    )\n  )\n\n  watchSyncEffect((onInvalidate) => {\n    if (source.value) {\n      loading.value = true\n      isStale.value = false\n\n      const invalidateStops = args.updateSubs!.map((sub) => {\n        return wonkaPipe(\n          client.value.executeSubscription(sub),\n          onEnd(() => {\n            if (source.value) execute()\n          }),\n          subscribe(() => {\n            return execute()\n          })\n        ).unsubscribe\n      })\n\n      invalidateStops.push(\n        wonkaPipe(\n          source.value,\n          onEnd(() => {\n            loading.value = false\n            isStale.value = false\n          }),\n          subscribe((res) => {\n            if (res.operation.key === request.value.key) {\n              data.value = pipe(\n                // The target\n                res.data as DocType | undefined,\n                // Define what happens if data does not exist (it is an error)\n                E.fromNullable(\n                  pipe(\n                    // Take the network error value\n                    res.error?.networkError,\n                    // If it null, set the left to the generic error name\n                    E.fromNullable(res.error?.message),\n                    E.match(\n                      // The left case (network error was null)\n                      (gqlErr) =>\n                        <GQLError<DocErrorType>>{\n                          type: \"gql_error\",\n                          error: parseGQLErrorString(\n                            gqlErr ?? \"\"\n                          ) as DocErrorType,\n                        },\n                      // The right case (it was a GraphQL Error)\n                      (networkErr) =>\n                        <GQLError<DocErrorType>>{\n                          type: \"network_error\",\n                          error: networkErr,\n                        }\n                    )\n                  )\n                )\n              )\n              loading.value = false\n            }\n          })\n        ).unsubscribe\n      )\n\n      onInvalidate(() => invalidateStops.forEach((unsub) => unsub()))\n    }\n  })\n\n  const execute = (updatedVars?: DocVarType) => {\n    if (updatedVars) {\n      if (isRef(args.variables)) {\n        args.variables.value = updatedVars\n      } else {\n        args.variables = updatedVars\n      }\n    }\n\n    isPaused.value = false\n    rerunQuery()\n  }\n\n  const pause = () => {\n    isPaused.value = true\n  }\n\n  const unpause = () => {\n    isPaused.value = false\n  }\n\n  const response = reactive({\n    loading,\n    data,\n    pause,\n    unpause,\n    isStale,\n    execute,\n  })\n\n  return response\n}\n"],"names":["useGQLQuery","_args","stops","args","reactive","loading","ref","isStale","data","isPaused","_a","pollDuration","_b","request","createRequest","unref","source","pollerTick","watchEffect","onInvalidate","handle","newRequest","rerunQuery","client","watch","watchSyncEffect","invalidateStops","sub","wonkaPipe","onEnd","execute","subscribe","res","pipe","E.fromNullable","E.match","gqlErr","parseGQLErrorString","networkErr","unsub","updatedVars","isRef"],"mappings":"4JAqCa,MAAAA,EACXC,GACG,SACH,MAAMC,EAA2B,CAAA,EAE3BC,EAAOC,EAASH,CAAK,EAErBI,EAAwBC,EAAI,EAAI,EAChCC,EAAwBD,EAAI,EAAI,EAChCE,EAAuDF,IAExDH,EAAK,aAAYA,EAAK,WAAa,IAExC,MAAMM,EAAyBH,GAAII,EAAAP,EAAK,QAAL,KAAAO,EAAc,EAAK,EAEhDC,EAAmCL,GAAIM,EAAAT,EAAK,eAAL,KAAAS,EAAqB,IAAI,EAEhEC,EAAoDP,EACxDQ,EACEX,EAAK,MACLY,EAAkBZ,EAAK,SAAgB,CACzC,CAAA,EAGIa,EAAmDV,IAGnDW,EAA2BX,EAAI,EAAI,EAEnCJ,EAAA,KACJgB,EAAaC,GAAiB,CAC5B,GAAIR,EAAa,QAAU,MAAQ,CAACF,EAAS,MAAO,CAC5C,MAAAW,EAAS,YAAY,IAAM,CACpBH,EAAA,MAAQ,CAACA,EAAW,KAAA,EAC9BN,EAAa,KAAK,EAErBQ,EAAa,IAAM,CACjB,cAAcC,CAAM,CAAA,CACrB,CACH,CAAA,CACD,CAAA,EAGGlB,EAAA,KACJgB,EACE,IAAM,CACJ,MAAMG,EAAaP,EACjBX,EAAK,MACLY,EAAkBZ,EAAK,SAAgB,CAAA,EAGrCU,EAAQ,MAAM,MAAQQ,EAAW,MACnCR,EAAQ,MAAQQ,EAEpB,EACA,CAAE,MAAO,KAAM,CACjB,CAAA,EAGF,MAAMC,EAAa,IAAM,CAChBN,EAAA,MAASP,EAAS,MAIrB,OAHAc,EAAO,MAAM,aAAkCV,EAAQ,MAAO,CAC5D,cAAe,cAAA,CAChB,CACD,EAGAX,EAAA,KACJsB,EACEP,EACA,IAAM,CACOK,GACb,EACA,CACE,MAAO,KACT,CACF,CAAA,EAGFG,EAAiBN,GAAiB,CAChC,GAAIH,EAAO,MAAO,CAChBX,EAAQ,MAAQ,GAChBE,EAAQ,MAAQ,GAEhB,MAAMmB,EAAkBvB,EAAK,WAAY,IAAKwB,GACrCC,EACLL,EAAO,MAAM,oBAAoBI,CAAG,EACpCE,EAAM,IAAM,CACNb,EAAO,OAAec,GAAA,CAC3B,EACDC,EAAU,IACDD,EAAQ,CAChB,CACD,EAAA,WACH,EAEeJ,EAAA,KACdE,EACEZ,EAAO,MACPa,EAAM,IAAM,CACVxB,EAAQ,MAAQ,GAChBE,EAAQ,MAAQ,EAAA,CACjB,EACDwB,EAAWC,GAAQ,SACbA,EAAI,UAAU,MAAQnB,EAAQ,MAAM,MACtCL,EAAK,MAAQyB,EAEXD,EAAI,KAEJE,EACED,GAEEvB,EAAAsB,EAAI,QAAJ,YAAAtB,EAAW,aAEXwB,GAAetB,EAAAoB,EAAI,QAAJ,YAAApB,EAAW,OAAO,EACjCuB,EAEGC,IACyB,CACtB,KAAM,YACN,MAAOC,EACLD,GAAA,KAAAA,EAAU,EACZ,CAAA,GAGHE,IACyB,CACtB,KAAM,gBACN,MAAOA,CAAA,EAEb,CACF,CACF,CAAA,EAEFjC,EAAQ,MAAQ,GAClB,CACD,CAAA,EACD,WAAA,EAGJc,EAAa,IAAMO,EAAgB,QAASa,GAAUA,EAAO,CAAA,CAAC,CAChE,CAAA,CACD,EAEK,MAAAT,EAAWU,GAA6B,CACxCA,IACEC,EAAMtC,EAAK,SAAS,EACtBA,EAAK,UAAU,MAAQqC,EAEvBrC,EAAK,UAAYqC,GAIrB/B,EAAS,MAAQ,GACNa,GAAA,EAoBN,OATUlB,EAAS,CACxB,QAAAC,EACA,KAAAG,EACA,MAXY,IAAM,CAClBC,EAAS,MAAQ,EAAA,EAWjB,QARc,IAAM,CACpBA,EAAS,MAAQ,EAAA,EAQjB,QAAAF,EACA,QAAAuB,CAAA,CACD,CAGH"}